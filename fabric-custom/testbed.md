::: {.cell .markdown}
## Testbed experiment on FABRIC
:::


::: {.cell .markdown}

Now we'll move on to an equivalent experiment, using the FABRIC testbed. This experiment highlights the following aspects of network research using simulation:

* Various details of the implementation of the network stack on an experimental host may cause our experiment assumptions to be violated, affecting the validity of the results.
* Compute capabilities can also affect the experiment results.
* Validating experiment assumptions is an important "sanity check" to catch some problems in the experiment.

:::


::: {.cell .code}
```python
# run this cell to "pick up" where you left off in a new session
from fabrictestbed_extensions.fablib.fablib import FablibManager as fablib_manager
fablib = fablib_manager() 
slice_name="mm1-" + fablib.get_bastion_username()
slice = fablib.get_slice(name=slice_name)
```
:::

::: {.cell .markdown}

To generate traffic with the desired distribution of packet sizes and interarrival times in this experiment, we will use a software traffic generator called D-ITG. We will start by learning how to use D-ITG.

You will need an SSH session on the "romeo" host and one on the "juliet" host.


:::

::: {.cell .markdown}

D-ITG comes with a suite of utilities for generating traffic, receiving traffic, parsing log files, and automating experiments. We will use learn how to use three of the D-ITG utilities: the sender (traffic generator), the receiver (traffic sink), and the log file decoder. We will run the sender on the client node, the receiver on the server node, and the log file decoder on both the client and server node.

Try it now with the following command on "juliet", the receiver (server) node:

```
ITGRecv
```

Leave that running, and on "romeo", the sender (client) node, run:

```
ITGSend -a juliet -l sender.log -x receiver.log -E 200 -e 512 -T UDP -t 240000
```

This will send UDP traffic to "juliet"" with a packet interarrival time that is exponentially distributed with mean 200 packets/second, packet size that is exponentially distributed with mean 512 bytes. It will run for 4 minutes (240000 ms), and will save the log files at the client node and server node with file names "sender.log" and "receiver.log" respectively.

Wait for the sender to finish, then stop the receiver process with Ctrl+C. Then, open the log on the receiver side with

```
ITGDec receiver.log
```

and on the sender side with

```
ITGDec sender.log
```


Here you can see some basic aggregate information about the generated traffic flow(s). More detailed information is available from the log file using various arguments; see the documentation for details. (Note that the one-way delay information reported is not reliable, since the clocks on the two nodes are not synchronized. You may even see a negative delay reported.)

In general, the basic usage of the sender will be as follows:

```
ITGSend -l SENDER-LOG -x RECEIVER-LOG -E MEAN-ARRIVAL-RATE -e MEAN-PACKET-SIZE  -t EXPERIMENT-DURATION -T UDP
```

where SENDER-LOG is the name to use for the log file at the sender side, RECEIVER-LOG is the name to use for the log file at the receiver side, MEAN-ARRIVAL-RATE is the mean rate at which to send traffic in packets per second (the -E indicates that the arrival rate will be exponentially distributed), MEAN-PACKET-SIZE is the mean size of the data payload of the packet in bytes (the -e indicates that the packet size will be exponentially distributed), and EXPERIMENT-DURATION is the length of the experiment in milliseconds (the default is 10 seconds). You can choose MEAN-ARRIVAL-RATE and MEAN-PACKET-SIZE to create a traffic pattern with any λ and any μ that you want. (For our experiments today, we will only vary λ and will keep the mean packet size constant.)

:::


::: {.cell .markdown}
In addition to traffic generation, we also need some way to record data about the packets that arrive at the router. We will use `tshark`, a utility similar to `tcpdump` but with more advanced display and data analysis options, to capture incoming traffic on the router node. The usage of this command will be:


```
sudo tshark -i $(ip route get 10.0.1.100 | grep -oP "(?<=dev )[^ ]+") -f "udp and port 8999" -T fields -e frame.time_delta_displayed -e frame.len -E separator=, > output.csv
```

Here,

* the `-i` flag specifies which network interface to listen on (this will be the experiment interface through which traffic enters the router from the "romeo" node),
* we use `-f "udp and port 8999"` to filter out traffic that is not generated by D-ITG,
* we specify a list of fields to print with `-T` fields:
  * `frame.time_delta_displayed` is the time delta between displayed frames
  * `frame.len` is the size of the frame, in bytes
* and we use a comma to separate fields in the output, with `-E separator=,`

We also redirect the output a file called "output.csv".

:::


::: {.cell .markdown}
Try it now:

* Run the `tshark` command above on on the router node
* Re-run the D-ITG sender and receiver commands on your romeo and juliet nodes. 

After these have finished, stop the `tshark` and D-ITG receiver with Ctrl+C. Then, the following cell will transfer the "output.csv" file to your workspace.

:::

::: {.cell .code}
```python
slice.get_node("router").download_file("output.csv", "/home/ubuntu/output.csv")
```
:::


::: {.cell .markdown}
Find this file in the file browser and open it, and note that the packet interarrival times and sizes are recorded.
:::


::: {.cell .markdown}

To realize an M/M/1 queue, we need two more "pieces", though: 

* We need to set the service rate of the queue (at the router!)
* and we need a way to measure the queue length.

We will use the Linux Traffic Control (`tc`) utility to manipulate queue settings, and we will use a type of queue called an `htb` (Hierarchical Token Bucket) that limits the service rate. As packets arrive at the router, they will wait in a queue (in the order in which they arrived, so FIFO - first in, first out), and they will be released only at the rate that we specify. Also, following the `htb` queue we will add a `bfifo` queue with a large capacity (so that packets will not be dropped).

:::


::: {.cell .markdown}

On the router, run

```
# the first line may raise an error "Error: Cannot delete qdisc with handle of zero."
# this is fine, and not a concern
sudo tc qdisc del dev $(ip route get 10.0.2.100 | grep -oP "(?<=dev )[^ ]+") root  
sudo tc qdisc replace dev $(ip route get 10.0.2.100 | grep -oP "(?<=dev )[^ ]+") root handle 1: htb default 3  
sudo tc class add dev $(ip route get 10.0.2.100 | grep -oP "(?<=dev )[^ ]+") parent 1: classid 1:3 htb rate 1mbit  
sudo tc qdisc add dev $(ip route get 10.0.2.100 | grep -oP "(?<=dev )[^ ]+") parent 1:3 handle 3: bfifo limit 500mbit  
```

to configure this queue.

:::
